/*
 * Telnyx API
 * SIP trunking, SMS, MMS, Call Control and Telephony Data Services.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: support@telnyx.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.telnyx.sdk.apis;

import com.telnyx.sdk.ApiClient;
import com.telnyx.sdk.ApiException;
import com.telnyx.sdk.ApiResponse;
import com.telnyx.sdk.Pair;

import com.telnyx.sdk.models.AnswerRequest;
import com.telnyx.sdk.models.BridgeRequest;
import com.telnyx.sdk.models.CallControlCommandResponse;
import com.telnyx.sdk.models.CallRequest;
import com.telnyx.sdk.models.Errors;
import com.telnyx.sdk.models.GatherUsingAudioRequest;
import com.telnyx.sdk.models.GatherUsingSpeakRequest;
import com.telnyx.sdk.models.HangupRequest;
import com.telnyx.sdk.models.PlayAudioUrlRequest;
import com.telnyx.sdk.models.PlaybackStopRequest;
import com.telnyx.sdk.models.RejectRequest;
import com.telnyx.sdk.models.RetrieveCallStatusResponse;
import com.telnyx.sdk.models.SendDTMFRequest;
import com.telnyx.sdk.models.SpeakRequest;
import com.telnyx.sdk.models.StartForkingRequest;
import com.telnyx.sdk.models.StartRecordingRequest;
import com.telnyx.sdk.models.StopForkingRequest;
import com.telnyx.sdk.models.StopGatherRequest;
import com.telnyx.sdk.models.StopRecordingRequest;
import com.telnyx.sdk.models.TransferCallRequest;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.function.Consumer;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;

import java.util.concurrent.CompletableFuture;

@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class CallCommandsApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;

  public CallCommandsApi() {
    this(new ApiClient());
  }

  public CallCommandsApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
  }

  private ApiException getApiException(String operationId, HttpResponse<String>localVarResponse) {
    return new ApiException(localVarResponse.statusCode(),
        operationId + " call received non-success response",
        localVarResponse.headers(),
        localVarResponse.body());
  }

  /**
   * Answer call
   * Answer an incoming call. You must issue this command before executing subsequent commands on an incoming call.  **Expected Webhooks:**  - &#x60;call.answered&#x60; 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param answerRequest Answer call request (required)
   * @return CompletableFuture&lt;CallControlCommandResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<CallControlCommandResponse> callAnswer(String callControlId, AnswerRequest answerRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callAnswerRequestBuilder(callControlId, answerRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callAnswer", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Answer call
   * Answer an incoming call. You must issue this command before executing subsequent commands on an incoming call.  **Expected Webhooks:**  - &#x60;call.answered&#x60; 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param answerRequest Answer call request (required)
   * @return CompletableFuture&lt;ApiResponse&lt;CallControlCommandResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<CallControlCommandResponse>> callAnswerWithHttpInfo(String callControlId, AnswerRequest answerRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callAnswerRequestBuilder(callControlId, answerRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callAnswer", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<CallControlCommandResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder callAnswerRequestBuilder(String callControlId, AnswerRequest answerRequest) throws ApiException {
    // verify the required parameter 'callControlId' is set
    if (callControlId == null) {
      throw new ApiException(400, "Missing the required parameter 'callControlId' when calling callAnswer");
    }
    // verify the required parameter 'answerRequest' is set
    if (answerRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'answerRequest' when calling callAnswer");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/calls/{call_control_id}/actions/answer"
        .replace("{call_control_id}", ApiClient.urlEncode(callControlId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(answerRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Bridge calls
   * Bridge two call control calls.  **Expected Webhooks:**  - &#x60;call.bridged&#x60; for Leg A - &#x60;call.bridged&#x60; for Leg B 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param bridgeRequest Bridge call request (required)
   * @return CompletableFuture&lt;CallControlCommandResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<CallControlCommandResponse> callBridge(String callControlId, BridgeRequest bridgeRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callBridgeRequestBuilder(callControlId, bridgeRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callBridge", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Bridge calls
   * Bridge two call control calls.  **Expected Webhooks:**  - &#x60;call.bridged&#x60; for Leg A - &#x60;call.bridged&#x60; for Leg B 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param bridgeRequest Bridge call request (required)
   * @return CompletableFuture&lt;ApiResponse&lt;CallControlCommandResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<CallControlCommandResponse>> callBridgeWithHttpInfo(String callControlId, BridgeRequest bridgeRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callBridgeRequestBuilder(callControlId, bridgeRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callBridge", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<CallControlCommandResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder callBridgeRequestBuilder(String callControlId, BridgeRequest bridgeRequest) throws ApiException {
    // verify the required parameter 'callControlId' is set
    if (callControlId == null) {
      throw new ApiException(400, "Missing the required parameter 'callControlId' when calling callBridge");
    }
    // verify the required parameter 'bridgeRequest' is set
    if (bridgeRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'bridgeRequest' when calling callBridge");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/calls/{call_control_id}/actions/bridge"
        .replace("{call_control_id}", ApiClient.urlEncode(callControlId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(bridgeRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Dial
   * Dial a number or SIP URI from a given connection. A successful response will include a &#x60;call_leg_id&#x60; which can be used to correlate the command with subsequent webhooks.  **Expected Webhooks:**  - &#x60;call.initiated&#x60; - &#x60;call.answered&#x60; or &#x60;call.hangup&#x60; - &#x60;call.machine.detection.ended&#x60; if &#x60;answering_machine_detection&#x60; was requested - &#x60;call.machine.greeting.ended&#x60; if &#x60;answering_machine_detection&#x60; was requested to detect the end of machine greeting - &#x60;call.machine.premium.detection.ended&#x60; if &#x60;answering_machine_detection&#x3D;premium&#x60; was requested - &#x60;call.machine.premium.greeting.ended&#x60; if &#x60;answering_machine_detection&#x3D;premium&#x60; was requested and a beep was detected 
   * @param callRequest Call request (required)
   * @return CompletableFuture&lt;RetrieveCallStatusResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<RetrieveCallStatusResponse> callDial(CallRequest callRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callDialRequestBuilder(callRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callDial", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<RetrieveCallStatusResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Dial
   * Dial a number or SIP URI from a given connection. A successful response will include a &#x60;call_leg_id&#x60; which can be used to correlate the command with subsequent webhooks.  **Expected Webhooks:**  - &#x60;call.initiated&#x60; - &#x60;call.answered&#x60; or &#x60;call.hangup&#x60; - &#x60;call.machine.detection.ended&#x60; if &#x60;answering_machine_detection&#x60; was requested - &#x60;call.machine.greeting.ended&#x60; if &#x60;answering_machine_detection&#x60; was requested to detect the end of machine greeting - &#x60;call.machine.premium.detection.ended&#x60; if &#x60;answering_machine_detection&#x3D;premium&#x60; was requested - &#x60;call.machine.premium.greeting.ended&#x60; if &#x60;answering_machine_detection&#x3D;premium&#x60; was requested and a beep was detected 
   * @param callRequest Call request (required)
   * @return CompletableFuture&lt;ApiResponse&lt;RetrieveCallStatusResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<RetrieveCallStatusResponse>> callDialWithHttpInfo(CallRequest callRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callDialRequestBuilder(callRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callDial", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<RetrieveCallStatusResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<RetrieveCallStatusResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder callDialRequestBuilder(CallRequest callRequest) throws ApiException {
    // verify the required parameter 'callRequest' is set
    if (callRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'callRequest' when calling callDial");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/calls";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(callRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Forking start
   * Call forking allows you to stream the media from a call to a specific target in realtime.  This stream can be used to enable realtime audio analysis to support a  variety of use cases, including fraud detection, or the creation of AI-generated audio responses.  Requests must specify either the &#x60;target&#x60; attribute or the &#x60;rx&#x60; and &#x60;tx&#x60; attributes.  **Expected Webhooks:**  - &#x60;call.fork.started&#x60; - &#x60;call.fork.stopped&#x60;  **Simple Telnyx RTP Encapsulation Protocol (STREP)**  *Note: This header/encapsulation is not used when the &#x60;rx&#x60; and &#x60;tx&#x60; parameters have been specified; it only applies when media is forked using the &#x60;target&#x60; attribute.*  If the destination for forked media is specified using the \&quot;target\&quot; attribute, the RTP will be encapsulated in an extra Telnyx protocol, which adds a 24 byte header to the RTP payload in each packet. The STREP header includes the Call Control &#x60;call_leg_id&#x60; for stream identification, along with bits that represent the direction (inbound or outbound) of the media. This 24-byte header sits between the UDP header and the RTP header.  The STREP header makes it possible to fork RTP for multiple calls (or two RTP streams for the same call) to the same IP:port, where the streams can be demultiplexed by your application using the information in the header. Of course, it&#39;s still possible to ignore this header completely, for example, if sending forked media for different calls to different ports or IP addresses. In this case, simply strip 24 bytes (or use the second byte to find the header length) from the received UDP payload to get the RTP (RTP header and payload).  &#x60;&#x60;&#x60; STREP Specification    0                   1                   2                   3   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |1 1|Version|L|D|    HeaderLen  |  reserved (2 bytes)           |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |       reserved (4 bytes, for UDP ports or anything else)      |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |               The call_leg_id                                 |  |                   from Call Control                           |  |                       (128 bits / 16 bytes)                   |  |                           (this is binary data)               |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   11    Static bits 11, always set to 11 to easily distinguish forked media    from RTP (10) and T.38 media (usually 00) and SIP (which begins    with a capital letter, so begins with bits 01). This is a magic number.   Version    Four bits to indicate the version number of the protocol, starting at 0001.   L    One bit to represent the leg of the call (A or B).    0 represents the A (first) leg of the call.    1 represents the B (second) leg of the call.   D    One bit to represent the direction of this RTP stream.    0 represents media received by Telnyx.    1 represents media transmitted by Telnyx.   HeaderLen (1 byte)    The length of the header in bytes.    Note that this value does not include the length of the payload. The total    size of the RTP can be calculated by subtracting the HeaderLen from the UDP    length (minus 8 for the UDP header).    In version 1, this value will always be 24.   Reserved (6 bytes)    Reserved for future use and to make sure that the header is a multiple of 32 bits   Call Leg ID    A 128-bit identifier for the call leg.    This is the call_leg_id from Call Control. &#x60;&#x60;&#x60; 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param startForkingRequest Fork media request (required)
   * @return CompletableFuture&lt;CallControlCommandResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<CallControlCommandResponse> callForkStart(String callControlId, StartForkingRequest startForkingRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callForkStartRequestBuilder(callControlId, startForkingRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callForkStart", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Forking start
   * Call forking allows you to stream the media from a call to a specific target in realtime.  This stream can be used to enable realtime audio analysis to support a  variety of use cases, including fraud detection, or the creation of AI-generated audio responses.  Requests must specify either the &#x60;target&#x60; attribute or the &#x60;rx&#x60; and &#x60;tx&#x60; attributes.  **Expected Webhooks:**  - &#x60;call.fork.started&#x60; - &#x60;call.fork.stopped&#x60;  **Simple Telnyx RTP Encapsulation Protocol (STREP)**  *Note: This header/encapsulation is not used when the &#x60;rx&#x60; and &#x60;tx&#x60; parameters have been specified; it only applies when media is forked using the &#x60;target&#x60; attribute.*  If the destination for forked media is specified using the \&quot;target\&quot; attribute, the RTP will be encapsulated in an extra Telnyx protocol, which adds a 24 byte header to the RTP payload in each packet. The STREP header includes the Call Control &#x60;call_leg_id&#x60; for stream identification, along with bits that represent the direction (inbound or outbound) of the media. This 24-byte header sits between the UDP header and the RTP header.  The STREP header makes it possible to fork RTP for multiple calls (or two RTP streams for the same call) to the same IP:port, where the streams can be demultiplexed by your application using the information in the header. Of course, it&#39;s still possible to ignore this header completely, for example, if sending forked media for different calls to different ports or IP addresses. In this case, simply strip 24 bytes (or use the second byte to find the header length) from the received UDP payload to get the RTP (RTP header and payload).  &#x60;&#x60;&#x60; STREP Specification    0                   1                   2                   3   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |1 1|Version|L|D|    HeaderLen  |  reserved (2 bytes)           |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |       reserved (4 bytes, for UDP ports or anything else)      |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |               The call_leg_id                                 |  |                   from Call Control                           |  |                       (128 bits / 16 bytes)                   |  |                           (this is binary data)               |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   11    Static bits 11, always set to 11 to easily distinguish forked media    from RTP (10) and T.38 media (usually 00) and SIP (which begins    with a capital letter, so begins with bits 01). This is a magic number.   Version    Four bits to indicate the version number of the protocol, starting at 0001.   L    One bit to represent the leg of the call (A or B).    0 represents the A (first) leg of the call.    1 represents the B (second) leg of the call.   D    One bit to represent the direction of this RTP stream.    0 represents media received by Telnyx.    1 represents media transmitted by Telnyx.   HeaderLen (1 byte)    The length of the header in bytes.    Note that this value does not include the length of the payload. The total    size of the RTP can be calculated by subtracting the HeaderLen from the UDP    length (minus 8 for the UDP header).    In version 1, this value will always be 24.   Reserved (6 bytes)    Reserved for future use and to make sure that the header is a multiple of 32 bits   Call Leg ID    A 128-bit identifier for the call leg.    This is the call_leg_id from Call Control. &#x60;&#x60;&#x60; 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param startForkingRequest Fork media request (required)
   * @return CompletableFuture&lt;ApiResponse&lt;CallControlCommandResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<CallControlCommandResponse>> callForkStartWithHttpInfo(String callControlId, StartForkingRequest startForkingRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callForkStartRequestBuilder(callControlId, startForkingRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callForkStart", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<CallControlCommandResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder callForkStartRequestBuilder(String callControlId, StartForkingRequest startForkingRequest) throws ApiException {
    // verify the required parameter 'callControlId' is set
    if (callControlId == null) {
      throw new ApiException(400, "Missing the required parameter 'callControlId' when calling callForkStart");
    }
    // verify the required parameter 'startForkingRequest' is set
    if (startForkingRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'startForkingRequest' when calling callForkStart");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/calls/{call_control_id}/actions/fork_start"
        .replace("{call_control_id}", ApiClient.urlEncode(callControlId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(startForkingRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Forking stop
   * Stop forking a call.  **Expected Webhooks:**  - &#x60;call.fork.stopped&#x60; 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param stopForkingRequest Stop forking media request (required)
   * @return CompletableFuture&lt;CallControlCommandResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<CallControlCommandResponse> callForkStop(String callControlId, StopForkingRequest stopForkingRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callForkStopRequestBuilder(callControlId, stopForkingRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callForkStop", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Forking stop
   * Stop forking a call.  **Expected Webhooks:**  - &#x60;call.fork.stopped&#x60; 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param stopForkingRequest Stop forking media request (required)
   * @return CompletableFuture&lt;ApiResponse&lt;CallControlCommandResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<CallControlCommandResponse>> callForkStopWithHttpInfo(String callControlId, StopForkingRequest stopForkingRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callForkStopRequestBuilder(callControlId, stopForkingRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callForkStop", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<CallControlCommandResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder callForkStopRequestBuilder(String callControlId, StopForkingRequest stopForkingRequest) throws ApiException {
    // verify the required parameter 'callControlId' is set
    if (callControlId == null) {
      throw new ApiException(400, "Missing the required parameter 'callControlId' when calling callForkStop");
    }
    // verify the required parameter 'stopForkingRequest' is set
    if (stopForkingRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'stopForkingRequest' when calling callForkStop");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/calls/{call_control_id}/actions/fork_stop"
        .replace("{call_control_id}", ApiClient.urlEncode(callControlId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(stopForkingRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Gather stop
   * Stop current gather.  **Expected Webhooks:**  - &#x60;call.gather.ended&#x60; 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param stopGatherRequest Stop current gather (required)
   * @return CompletableFuture&lt;CallControlCommandResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<CallControlCommandResponse> callGatherStop(String callControlId, StopGatherRequest stopGatherRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callGatherStopRequestBuilder(callControlId, stopGatherRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callGatherStop", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Gather stop
   * Stop current gather.  **Expected Webhooks:**  - &#x60;call.gather.ended&#x60; 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param stopGatherRequest Stop current gather (required)
   * @return CompletableFuture&lt;ApiResponse&lt;CallControlCommandResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<CallControlCommandResponse>> callGatherStopWithHttpInfo(String callControlId, StopGatherRequest stopGatherRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callGatherStopRequestBuilder(callControlId, stopGatherRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callGatherStop", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<CallControlCommandResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder callGatherStopRequestBuilder(String callControlId, StopGatherRequest stopGatherRequest) throws ApiException {
    // verify the required parameter 'callControlId' is set
    if (callControlId == null) {
      throw new ApiException(400, "Missing the required parameter 'callControlId' when calling callGatherStop");
    }
    // verify the required parameter 'stopGatherRequest' is set
    if (stopGatherRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'stopGatherRequest' when calling callGatherStop");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/calls/{call_control_id}/actions/gather_stop"
        .replace("{call_control_id}", ApiClient.urlEncode(callControlId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(stopGatherRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Gather using audio
   * Play an audio file on the call until the required DTMF signals are gathered to build interactive menus.  You can pass a list of valid digits along with an &#39;invalid_audio_url&#39;, which will be played back at the beginning of each prompt. Playback will be interrupted when a DTMF signal is received. The [Answer](/docs/api/v2/call-control/Call-Commands#CallControlAnswer) command must be issued before the &#x60;gather_using_audio&#x60; command.  **Expected Webhooks:**  - &#x60;call.playback.started&#x60; - &#x60;call.playback.ended&#x60; - &#x60;call.dtmf.received&#x60; (you may receive many of these webhooks) - &#x60;call.gather.ended&#x60; 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param gatherUsingAudioRequest Gather using audio request (required)
   * @return CompletableFuture&lt;CallControlCommandResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<CallControlCommandResponse> callGatherUsingAudio(String callControlId, GatherUsingAudioRequest gatherUsingAudioRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callGatherUsingAudioRequestBuilder(callControlId, gatherUsingAudioRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callGatherUsingAudio", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Gather using audio
   * Play an audio file on the call until the required DTMF signals are gathered to build interactive menus.  You can pass a list of valid digits along with an &#39;invalid_audio_url&#39;, which will be played back at the beginning of each prompt. Playback will be interrupted when a DTMF signal is received. The [Answer](/docs/api/v2/call-control/Call-Commands#CallControlAnswer) command must be issued before the &#x60;gather_using_audio&#x60; command.  **Expected Webhooks:**  - &#x60;call.playback.started&#x60; - &#x60;call.playback.ended&#x60; - &#x60;call.dtmf.received&#x60; (you may receive many of these webhooks) - &#x60;call.gather.ended&#x60; 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param gatherUsingAudioRequest Gather using audio request (required)
   * @return CompletableFuture&lt;ApiResponse&lt;CallControlCommandResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<CallControlCommandResponse>> callGatherUsingAudioWithHttpInfo(String callControlId, GatherUsingAudioRequest gatherUsingAudioRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callGatherUsingAudioRequestBuilder(callControlId, gatherUsingAudioRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callGatherUsingAudio", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<CallControlCommandResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder callGatherUsingAudioRequestBuilder(String callControlId, GatherUsingAudioRequest gatherUsingAudioRequest) throws ApiException {
    // verify the required parameter 'callControlId' is set
    if (callControlId == null) {
      throw new ApiException(400, "Missing the required parameter 'callControlId' when calling callGatherUsingAudio");
    }
    // verify the required parameter 'gatherUsingAudioRequest' is set
    if (gatherUsingAudioRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'gatherUsingAudioRequest' when calling callGatherUsingAudio");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/calls/{call_control_id}/actions/gather_using_audio"
        .replace("{call_control_id}", ApiClient.urlEncode(callControlId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(gatherUsingAudioRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Gather using speak
   * Convert text to speech and play it on the call until the required DTMF signals are gathered to build interactive menus.  You can pass a list of valid digits along with an &#39;invalid_payload&#39;, which will be played back at the beginning of each prompt. Speech will be interrupted when a DTMF signal is received. The [Answer](/docs/api/v2/call-control/Call-Commands#CallControlAnswer) command must be issued before the &#x60;gather_using_speak&#x60; command.  **Expected Webhooks:**  - &#x60;call.dtmf.received&#x60; (you may receive many of these webhooks) - &#x60;call.gather.ended&#x60; 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param gatherUsingSpeakRequest Gather using speak request (required)
   * @return CompletableFuture&lt;CallControlCommandResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<CallControlCommandResponse> callGatherUsingSpeak(String callControlId, GatherUsingSpeakRequest gatherUsingSpeakRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callGatherUsingSpeakRequestBuilder(callControlId, gatherUsingSpeakRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callGatherUsingSpeak", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Gather using speak
   * Convert text to speech and play it on the call until the required DTMF signals are gathered to build interactive menus.  You can pass a list of valid digits along with an &#39;invalid_payload&#39;, which will be played back at the beginning of each prompt. Speech will be interrupted when a DTMF signal is received. The [Answer](/docs/api/v2/call-control/Call-Commands#CallControlAnswer) command must be issued before the &#x60;gather_using_speak&#x60; command.  **Expected Webhooks:**  - &#x60;call.dtmf.received&#x60; (you may receive many of these webhooks) - &#x60;call.gather.ended&#x60; 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param gatherUsingSpeakRequest Gather using speak request (required)
   * @return CompletableFuture&lt;ApiResponse&lt;CallControlCommandResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<CallControlCommandResponse>> callGatherUsingSpeakWithHttpInfo(String callControlId, GatherUsingSpeakRequest gatherUsingSpeakRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callGatherUsingSpeakRequestBuilder(callControlId, gatherUsingSpeakRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callGatherUsingSpeak", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<CallControlCommandResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder callGatherUsingSpeakRequestBuilder(String callControlId, GatherUsingSpeakRequest gatherUsingSpeakRequest) throws ApiException {
    // verify the required parameter 'callControlId' is set
    if (callControlId == null) {
      throw new ApiException(400, "Missing the required parameter 'callControlId' when calling callGatherUsingSpeak");
    }
    // verify the required parameter 'gatherUsingSpeakRequest' is set
    if (gatherUsingSpeakRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'gatherUsingSpeakRequest' when calling callGatherUsingSpeak");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/calls/{call_control_id}/actions/gather_using_speak"
        .replace("{call_control_id}", ApiClient.urlEncode(callControlId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(gatherUsingSpeakRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Hangup call
   * Hang up the call.  **Expected Webhooks:**  - &#x60;call.hangup&#x60; - &#x60;call.recording.saved&#x60; 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param hangupRequest Hangup request (required)
   * @return CompletableFuture&lt;CallControlCommandResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<CallControlCommandResponse> callHangup(String callControlId, HangupRequest hangupRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callHangupRequestBuilder(callControlId, hangupRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callHangup", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Hangup call
   * Hang up the call.  **Expected Webhooks:**  - &#x60;call.hangup&#x60; - &#x60;call.recording.saved&#x60; 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param hangupRequest Hangup request (required)
   * @return CompletableFuture&lt;ApiResponse&lt;CallControlCommandResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<CallControlCommandResponse>> callHangupWithHttpInfo(String callControlId, HangupRequest hangupRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callHangupRequestBuilder(callControlId, hangupRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callHangup", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<CallControlCommandResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder callHangupRequestBuilder(String callControlId, HangupRequest hangupRequest) throws ApiException {
    // verify the required parameter 'callControlId' is set
    if (callControlId == null) {
      throw new ApiException(400, "Missing the required parameter 'callControlId' when calling callHangup");
    }
    // verify the required parameter 'hangupRequest' is set
    if (hangupRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'hangupRequest' when calling callHangup");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/calls/{call_control_id}/actions/hangup"
        .replace("{call_control_id}", ApiClient.urlEncode(callControlId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(hangupRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Play audio URL
   * Play an audio file on the call. If multiple play audio commands are issued consecutively, the audio files will be placed in a queue awaiting playback.  *Notes:*  - When &#x60;overlay&#x60; is enabled, &#x60;loop&#x60; is limited to 1, and &#x60;target_legs&#x60; is limited to &#x60;self&#x60;. - A customer cannot Play Audio with &#x60;overlay&#x3D;true&#x60; unless there is a Play Audio with &#x60;overlay&#x3D;false&#x60; actively playing.  **Expected Webhooks:**  - &#x60;call.playback.started&#x60; - &#x60;call.playback.ended&#x60; 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param playAudioUrlRequest Play audio URL request (required)
   * @return CompletableFuture&lt;CallControlCommandResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<CallControlCommandResponse> callPlaybackStart(String callControlId, PlayAudioUrlRequest playAudioUrlRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callPlaybackStartRequestBuilder(callControlId, playAudioUrlRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callPlaybackStart", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Play audio URL
   * Play an audio file on the call. If multiple play audio commands are issued consecutively, the audio files will be placed in a queue awaiting playback.  *Notes:*  - When &#x60;overlay&#x60; is enabled, &#x60;loop&#x60; is limited to 1, and &#x60;target_legs&#x60; is limited to &#x60;self&#x60;. - A customer cannot Play Audio with &#x60;overlay&#x3D;true&#x60; unless there is a Play Audio with &#x60;overlay&#x3D;false&#x60; actively playing.  **Expected Webhooks:**  - &#x60;call.playback.started&#x60; - &#x60;call.playback.ended&#x60; 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param playAudioUrlRequest Play audio URL request (required)
   * @return CompletableFuture&lt;ApiResponse&lt;CallControlCommandResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<CallControlCommandResponse>> callPlaybackStartWithHttpInfo(String callControlId, PlayAudioUrlRequest playAudioUrlRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callPlaybackStartRequestBuilder(callControlId, playAudioUrlRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callPlaybackStart", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<CallControlCommandResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder callPlaybackStartRequestBuilder(String callControlId, PlayAudioUrlRequest playAudioUrlRequest) throws ApiException {
    // verify the required parameter 'callControlId' is set
    if (callControlId == null) {
      throw new ApiException(400, "Missing the required parameter 'callControlId' when calling callPlaybackStart");
    }
    // verify the required parameter 'playAudioUrlRequest' is set
    if (playAudioUrlRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'playAudioUrlRequest' when calling callPlaybackStart");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/calls/{call_control_id}/actions/playback_start"
        .replace("{call_control_id}", ApiClient.urlEncode(callControlId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(playAudioUrlRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Stop audio playback
   * Stop audio being played on the call.  **Expected Webhooks:**  - &#x60;call.playback.ended&#x60; or &#x60;call.speak.ended&#x60; 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param playbackStopRequest Stop audio playback request (required)
   * @return CompletableFuture&lt;CallControlCommandResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<CallControlCommandResponse> callPlaybackStop(String callControlId, PlaybackStopRequest playbackStopRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callPlaybackStopRequestBuilder(callControlId, playbackStopRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callPlaybackStop", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Stop audio playback
   * Stop audio being played on the call.  **Expected Webhooks:**  - &#x60;call.playback.ended&#x60; or &#x60;call.speak.ended&#x60; 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param playbackStopRequest Stop audio playback request (required)
   * @return CompletableFuture&lt;ApiResponse&lt;CallControlCommandResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<CallControlCommandResponse>> callPlaybackStopWithHttpInfo(String callControlId, PlaybackStopRequest playbackStopRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callPlaybackStopRequestBuilder(callControlId, playbackStopRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callPlaybackStop", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<CallControlCommandResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder callPlaybackStopRequestBuilder(String callControlId, PlaybackStopRequest playbackStopRequest) throws ApiException {
    // verify the required parameter 'callControlId' is set
    if (callControlId == null) {
      throw new ApiException(400, "Missing the required parameter 'callControlId' when calling callPlaybackStop");
    }
    // verify the required parameter 'playbackStopRequest' is set
    if (playbackStopRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'playbackStopRequest' when calling callPlaybackStop");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/calls/{call_control_id}/actions/playback_stop"
        .replace("{call_control_id}", ApiClient.urlEncode(callControlId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(playbackStopRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Recording start
   * Start recording the call. Recording will stop on call hang-up, or can be initiated via the Stop Recording command.  **Expected Webhooks:**  - &#x60;call.recording.saved&#x60; 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param startRecordingRequest Start recording audio request (required)
   * @return CompletableFuture&lt;CallControlCommandResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<CallControlCommandResponse> callRecordStart(String callControlId, StartRecordingRequest startRecordingRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callRecordStartRequestBuilder(callControlId, startRecordingRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callRecordStart", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Recording start
   * Start recording the call. Recording will stop on call hang-up, or can be initiated via the Stop Recording command.  **Expected Webhooks:**  - &#x60;call.recording.saved&#x60; 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param startRecordingRequest Start recording audio request (required)
   * @return CompletableFuture&lt;ApiResponse&lt;CallControlCommandResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<CallControlCommandResponse>> callRecordStartWithHttpInfo(String callControlId, StartRecordingRequest startRecordingRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callRecordStartRequestBuilder(callControlId, startRecordingRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callRecordStart", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<CallControlCommandResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder callRecordStartRequestBuilder(String callControlId, StartRecordingRequest startRecordingRequest) throws ApiException {
    // verify the required parameter 'callControlId' is set
    if (callControlId == null) {
      throw new ApiException(400, "Missing the required parameter 'callControlId' when calling callRecordStart");
    }
    // verify the required parameter 'startRecordingRequest' is set
    if (startRecordingRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'startRecordingRequest' when calling callRecordStart");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/calls/{call_control_id}/actions/record_start"
        .replace("{call_control_id}", ApiClient.urlEncode(callControlId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(startRecordingRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Recording stop
   * Stop recording the call.  **Expected Webhooks:**  - &#x60;call.recording.saved&#x60; 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param stopRecordingRequest Stop recording call request (required)
   * @return CompletableFuture&lt;CallControlCommandResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<CallControlCommandResponse> callRecordStop(String callControlId, StopRecordingRequest stopRecordingRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callRecordStopRequestBuilder(callControlId, stopRecordingRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callRecordStop", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Recording stop
   * Stop recording the call.  **Expected Webhooks:**  - &#x60;call.recording.saved&#x60; 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param stopRecordingRequest Stop recording call request (required)
   * @return CompletableFuture&lt;ApiResponse&lt;CallControlCommandResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<CallControlCommandResponse>> callRecordStopWithHttpInfo(String callControlId, StopRecordingRequest stopRecordingRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callRecordStopRequestBuilder(callControlId, stopRecordingRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callRecordStop", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<CallControlCommandResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder callRecordStopRequestBuilder(String callControlId, StopRecordingRequest stopRecordingRequest) throws ApiException {
    // verify the required parameter 'callControlId' is set
    if (callControlId == null) {
      throw new ApiException(400, "Missing the required parameter 'callControlId' when calling callRecordStop");
    }
    // verify the required parameter 'stopRecordingRequest' is set
    if (stopRecordingRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'stopRecordingRequest' when calling callRecordStop");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/calls/{call_control_id}/actions/record_stop"
        .replace("{call_control_id}", ApiClient.urlEncode(callControlId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(stopRecordingRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Reject a call
   * Reject an incoming call.  **Expected Webhooks:**  - &#x60;call.hangup&#x60; 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param rejectRequest Reject request (required)
   * @return CompletableFuture&lt;CallControlCommandResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<CallControlCommandResponse> callReject(String callControlId, RejectRequest rejectRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callRejectRequestBuilder(callControlId, rejectRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callReject", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Reject a call
   * Reject an incoming call.  **Expected Webhooks:**  - &#x60;call.hangup&#x60; 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param rejectRequest Reject request (required)
   * @return CompletableFuture&lt;ApiResponse&lt;CallControlCommandResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<CallControlCommandResponse>> callRejectWithHttpInfo(String callControlId, RejectRequest rejectRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callRejectRequestBuilder(callControlId, rejectRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callReject", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<CallControlCommandResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder callRejectRequestBuilder(String callControlId, RejectRequest rejectRequest) throws ApiException {
    // verify the required parameter 'callControlId' is set
    if (callControlId == null) {
      throw new ApiException(400, "Missing the required parameter 'callControlId' when calling callReject");
    }
    // verify the required parameter 'rejectRequest' is set
    if (rejectRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'rejectRequest' when calling callReject");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/calls/{call_control_id}/actions/reject"
        .replace("{call_control_id}", ApiClient.urlEncode(callControlId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(rejectRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Send DTMF
   * Sends DTMF tones from this leg. DTMF tones will be heard by the other end of the call.  **Expected Webhooks:**  There are no webhooks associated with this command. 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param sendDTMFRequest Send DTMF request (required)
   * @return CompletableFuture&lt;CallControlCommandResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<CallControlCommandResponse> callSendDTMF(String callControlId, SendDTMFRequest sendDTMFRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callSendDTMFRequestBuilder(callControlId, sendDTMFRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callSendDTMF", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Send DTMF
   * Sends DTMF tones from this leg. DTMF tones will be heard by the other end of the call.  **Expected Webhooks:**  There are no webhooks associated with this command. 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param sendDTMFRequest Send DTMF request (required)
   * @return CompletableFuture&lt;ApiResponse&lt;CallControlCommandResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<CallControlCommandResponse>> callSendDTMFWithHttpInfo(String callControlId, SendDTMFRequest sendDTMFRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callSendDTMFRequestBuilder(callControlId, sendDTMFRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callSendDTMF", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<CallControlCommandResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder callSendDTMFRequestBuilder(String callControlId, SendDTMFRequest sendDTMFRequest) throws ApiException {
    // verify the required parameter 'callControlId' is set
    if (callControlId == null) {
      throw new ApiException(400, "Missing the required parameter 'callControlId' when calling callSendDTMF");
    }
    // verify the required parameter 'sendDTMFRequest' is set
    if (sendDTMFRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'sendDTMFRequest' when calling callSendDTMF");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/calls/{call_control_id}/actions/send_dtmf"
        .replace("{call_control_id}", ApiClient.urlEncode(callControlId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(sendDTMFRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Speak text
   * Convert text to speech and play it back on the call. If multiple speak text commands are issued consecutively, the audio files will be placed in a queue awaiting playback.  **Expected Webhooks:**  - &#x60;call.speak.started&#x60; - &#x60;call.speak.ended&#x60; 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param speakRequest Speak request (required)
   * @return CompletableFuture&lt;CallControlCommandResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<CallControlCommandResponse> callSpeak(String callControlId, SpeakRequest speakRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callSpeakRequestBuilder(callControlId, speakRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callSpeak", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Speak text
   * Convert text to speech and play it back on the call. If multiple speak text commands are issued consecutively, the audio files will be placed in a queue awaiting playback.  **Expected Webhooks:**  - &#x60;call.speak.started&#x60; - &#x60;call.speak.ended&#x60; 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param speakRequest Speak request (required)
   * @return CompletableFuture&lt;ApiResponse&lt;CallControlCommandResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<CallControlCommandResponse>> callSpeakWithHttpInfo(String callControlId, SpeakRequest speakRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callSpeakRequestBuilder(callControlId, speakRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callSpeak", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<CallControlCommandResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder callSpeakRequestBuilder(String callControlId, SpeakRequest speakRequest) throws ApiException {
    // verify the required parameter 'callControlId' is set
    if (callControlId == null) {
      throw new ApiException(400, "Missing the required parameter 'callControlId' when calling callSpeak");
    }
    // verify the required parameter 'speakRequest' is set
    if (speakRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'speakRequest' when calling callSpeak");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/calls/{call_control_id}/actions/speak"
        .replace("{call_control_id}", ApiClient.urlEncode(callControlId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(speakRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Transfer call
   * Transfer a call to a new destination. If the transfer is unsuccessful, a &#x60;call.hangup&#x60; webhook for the other call (Leg B) will be sent indicating that the transfer could not be completed. The original call will remain active and may be issued additional commands, potentially transfering the call to an alternate destination.  **Expected Webhooks:**  - &#x60;call.initiated&#x60; - &#x60;call.bridged&#x60; to Leg B - &#x60;call.answered&#x60; or &#x60;call.hangup&#x60; - &#x60;call.machine.detection.ended&#x60; if &#x60;answering_machine_detection&#x60; was requested - &#x60;call.machine.greeting.ended&#x60; if &#x60;answering_machine_detection&#x60; was requested to detect the end of machine greeting - &#x60;call.machine.premium.detection.ended&#x60; if &#x60;answering_machine_detection&#x3D;premium&#x60; was requested - &#x60;call.machine.premium.greeting.ended&#x60; if &#x60;answering_machine_detection&#x3D;premium&#x60; was requested and a beep was detected 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param transferCallRequest Transfer call request (required)
   * @return CompletableFuture&lt;CallControlCommandResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<CallControlCommandResponse> callTransfer(String callControlId, TransferCallRequest transferCallRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callTransferRequestBuilder(callControlId, transferCallRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callTransfer", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Transfer call
   * Transfer a call to a new destination. If the transfer is unsuccessful, a &#x60;call.hangup&#x60; webhook for the other call (Leg B) will be sent indicating that the transfer could not be completed. The original call will remain active and may be issued additional commands, potentially transfering the call to an alternate destination.  **Expected Webhooks:**  - &#x60;call.initiated&#x60; - &#x60;call.bridged&#x60; to Leg B - &#x60;call.answered&#x60; or &#x60;call.hangup&#x60; - &#x60;call.machine.detection.ended&#x60; if &#x60;answering_machine_detection&#x60; was requested - &#x60;call.machine.greeting.ended&#x60; if &#x60;answering_machine_detection&#x60; was requested to detect the end of machine greeting - &#x60;call.machine.premium.detection.ended&#x60; if &#x60;answering_machine_detection&#x3D;premium&#x60; was requested - &#x60;call.machine.premium.greeting.ended&#x60; if &#x60;answering_machine_detection&#x3D;premium&#x60; was requested and a beep was detected 
   * @param callControlId Unique identifier and token for controlling the call (required)
   * @param transferCallRequest Transfer call request (required)
   * @return CompletableFuture&lt;ApiResponse&lt;CallControlCommandResponse&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<CallControlCommandResponse>> callTransferWithHttpInfo(String callControlId, TransferCallRequest transferCallRequest) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = callTransferRequestBuilder(callControlId, transferCallRequest);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("callTransfer", localVarResponse));
            }
            try {
              return CompletableFuture.completedFuture(
                  new ApiResponse<CallControlCommandResponse>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CallControlCommandResponse>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder callTransferRequestBuilder(String callControlId, TransferCallRequest transferCallRequest) throws ApiException {
    // verify the required parameter 'callControlId' is set
    if (callControlId == null) {
      throw new ApiException(400, "Missing the required parameter 'callControlId' when calling callTransfer");
    }
    // verify the required parameter 'transferCallRequest' is set
    if (transferCallRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'transferCallRequest' when calling callTransfer");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/calls/{call_control_id}/actions/transfer"
        .replace("{call_control_id}", ApiClient.urlEncode(callControlId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(transferCallRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
}
