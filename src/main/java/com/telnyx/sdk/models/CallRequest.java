/*
 * Telnyx API
 * SIP trunking, SMS, MMS, Call Control and Telephony Data Services.
 *
 * OpenAPI spec version: 2.0.0
 * Contact: support@telnyx.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.telnyx.sdk.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.telnyx.sdk.models.CallRequestAnsweringMachineDetectionConfig;
import com.telnyx.sdk.models.CustomSipHeader;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * CallRequest
 */


public class CallRequest {
  @SerializedName("to")
  private String to = null;

  @SerializedName("from")
  private String from = null;

  @SerializedName("connection_id")
  private String connectionId = null;

  @SerializedName("audio_url")
  private String audioUrl = null;

  @SerializedName("timeout_secs")
  private Integer timeoutSecs = 30;

  @SerializedName("time_limit_secs")
  private Integer timeLimitSecs = 14400;

  /**
   * Enables Answering Machine Detection. When a call is answered, Telnyx runs real-time detection to determine if it was picked up by a human or a machine and sends an &#x60;call.machine.detection.ended&#x60; webhook with the analysis result. If &#x27;greeting_end&#x27; or &#x27;detect_words&#x27; is used and a &#x27;machine&#x27; is detected, you will receive another &#x27;call.machine.greeting.ended&#x27; webhook when the answering machine greeting ends with a beep or silence. If &#x60;detect_beep&#x60; is used, you will only receive &#x27;call.machine.greeting.ended&#x27; if a beep is detected.
   */
  @JsonAdapter(AnsweringMachineDetectionEnum.Adapter.class)
  public enum AnsweringMachineDetectionEnum {
    DETECT("detect"),
    DETECT_BEEP("detect_beep"),
    DETECT_WORDS("detect_words"),
    GREETING_END("greeting_end"),
    DISABLED("disabled");

    private String value;

    AnsweringMachineDetectionEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static AnsweringMachineDetectionEnum fromValue(String text) {
      for (AnsweringMachineDetectionEnum b : AnsweringMachineDetectionEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<AnsweringMachineDetectionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AnsweringMachineDetectionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AnsweringMachineDetectionEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return AnsweringMachineDetectionEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("answering_machine_detection")
  private AnsweringMachineDetectionEnum answeringMachineDetection = AnsweringMachineDetectionEnum.DISABLED;

  @SerializedName("answering_machine_detection_config")
  private CallRequestAnsweringMachineDetectionConfig answeringMachineDetectionConfig = null;

  @SerializedName("custom_headers")
  private List<CustomSipHeader> customHeaders = null;

  @SerializedName("client_state")
  private String clientState = null;

  @SerializedName("command_id")
  private String commandId = null;

  @SerializedName("link_to")
  private String linkTo = null;

  @SerializedName("sip_auth_username")
  private String sipAuthUsername = null;

  @SerializedName("sip_auth_password")
  private String sipAuthPassword = null;

  @SerializedName("webhook_url")
  private String webhookUrl = null;

  /**
   * HTTP request type used for &#x60;webhook_url&#x60;.
   */
  @JsonAdapter(WebhookUrlMethodEnum.Adapter.class)
  public enum WebhookUrlMethodEnum {
    POST("POST"),
    GET("GET");

    private String value;

    WebhookUrlMethodEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static WebhookUrlMethodEnum fromValue(String text) {
      for (WebhookUrlMethodEnum b : WebhookUrlMethodEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<WebhookUrlMethodEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final WebhookUrlMethodEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public WebhookUrlMethodEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return WebhookUrlMethodEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("webhook_url_method")
  private WebhookUrlMethodEnum webhookUrlMethod = WebhookUrlMethodEnum.POST;

  public CallRequest to(String to) {
    this.to = to;
    return this;
  }

   /**
   * The DID or SIP URI to dial out to.
   * @return to
  **/
  @Schema(example = "+18005550100 or SIP:username@sip.telnyx.com", required = true, description = "The DID or SIP URI to dial out to.")
  public String getTo() {
    return to;
  }

  public void setTo(String to) {
    this.to = to;
  }

  public CallRequest from(String from) {
    this.from = from;
    return this;
  }

   /**
   * The &#x60;from&#x60; number to be used as the caller id presented to the destination (&#x60;to&#x60; number). The number should be in +E164 format. This attribute will default to the &#x60;from&#x60; number of the original call if omitted.
   * @return from
  **/
  @Schema(example = "+18005550101", required = true, description = "The `from` number to be used as the caller id presented to the destination (`to` number). The number should be in +E164 format. This attribute will default to the `from` number of the original call if omitted.")
  public String getFrom() {
    return from;
  }

  public void setFrom(String from) {
    this.from = from;
  }

  public CallRequest connectionId(String connectionId) {
    this.connectionId = connectionId;
    return this;
  }

   /**
   * The ID of the connection to be used when dialing the destination.
   * @return connectionId
  **/
  @Schema(required = true, description = "The ID of the connection to be used when dialing the destination.")
  public String getConnectionId() {
    return connectionId;
  }

  public void setConnectionId(String connectionId) {
    this.connectionId = connectionId;
  }

  public CallRequest audioUrl(String audioUrl) {
    this.audioUrl = audioUrl;
    return this;
  }

   /**
   * The URL of a file to be played back to the callee when the call is answered. The URL can point to either a WAV or MP3 file.
   * @return audioUrl
  **/
  @Schema(example = "http://example.com/message.wav", description = "The URL of a file to be played back to the callee when the call is answered. The URL can point to either a WAV or MP3 file.")
  public String getAudioUrl() {
    return audioUrl;
  }

  public void setAudioUrl(String audioUrl) {
    this.audioUrl = audioUrl;
  }

  public CallRequest timeoutSecs(Integer timeoutSecs) {
    this.timeoutSecs = timeoutSecs;
    return this;
  }

   /**
   * The number of seconds that Telnyx will wait for the call to be answered by the destination to which it is being called. If the timeout is reached before an answer is received, the call will hangup and a &#x60;call.hangup&#x60; webhook with a &#x60;hangup_cause&#x60; of &#x60;timeout&#x60; will be sent. Minimum value is 5 seconds. Maximum value is 120 seconds.
   * @return timeoutSecs
  **/
  @Schema(example = "60", description = "The number of seconds that Telnyx will wait for the call to be answered by the destination to which it is being called. If the timeout is reached before an answer is received, the call will hangup and a `call.hangup` webhook with a `hangup_cause` of `timeout` will be sent. Minimum value is 5 seconds. Maximum value is 120 seconds.")
  public Integer getTimeoutSecs() {
    return timeoutSecs;
  }

  public void setTimeoutSecs(Integer timeoutSecs) {
    this.timeoutSecs = timeoutSecs;
  }

  public CallRequest timeLimitSecs(Integer timeLimitSecs) {
    this.timeLimitSecs = timeLimitSecs;
    return this;
  }

   /**
   * Sets the maximum duration of a Call Control Leg in seconds. If the time limit is reached, the call will hangup and a &#x60;call.hangup&#x60; webhook with a &#x60;hangup_cause&#x60; of &#x60;time_limit&#x60; will be sent. For example, by setting a time limit of 120 seconds, a Call Leg will be automatically terminated two minutes after being answered. The default time limit is 14400 seconds or 4 hours and this is also the maximum allowed call length.
   * @return timeLimitSecs
  **/
  @Schema(example = "600", description = "Sets the maximum duration of a Call Control Leg in seconds. If the time limit is reached, the call will hangup and a `call.hangup` webhook with a `hangup_cause` of `time_limit` will be sent. For example, by setting a time limit of 120 seconds, a Call Leg will be automatically terminated two minutes after being answered. The default time limit is 14400 seconds or 4 hours and this is also the maximum allowed call length.")
  public Integer getTimeLimitSecs() {
    return timeLimitSecs;
  }

  public void setTimeLimitSecs(Integer timeLimitSecs) {
    this.timeLimitSecs = timeLimitSecs;
  }

  public CallRequest answeringMachineDetection(AnsweringMachineDetectionEnum answeringMachineDetection) {
    this.answeringMachineDetection = answeringMachineDetection;
    return this;
  }

   /**
   * Enables Answering Machine Detection. When a call is answered, Telnyx runs real-time detection to determine if it was picked up by a human or a machine and sends an &#x60;call.machine.detection.ended&#x60; webhook with the analysis result. If &#x27;greeting_end&#x27; or &#x27;detect_words&#x27; is used and a &#x27;machine&#x27; is detected, you will receive another &#x27;call.machine.greeting.ended&#x27; webhook when the answering machine greeting ends with a beep or silence. If &#x60;detect_beep&#x60; is used, you will only receive &#x27;call.machine.greeting.ended&#x27; if a beep is detected.
   * @return answeringMachineDetection
  **/
  @Schema(description = "Enables Answering Machine Detection. When a call is answered, Telnyx runs real-time detection to determine if it was picked up by a human or a machine and sends an `call.machine.detection.ended` webhook with the analysis result. If 'greeting_end' or 'detect_words' is used and a 'machine' is detected, you will receive another 'call.machine.greeting.ended' webhook when the answering machine greeting ends with a beep or silence. If `detect_beep` is used, you will only receive 'call.machine.greeting.ended' if a beep is detected.")
  public AnsweringMachineDetectionEnum getAnsweringMachineDetection() {
    return answeringMachineDetection;
  }

  public void setAnsweringMachineDetection(AnsweringMachineDetectionEnum answeringMachineDetection) {
    this.answeringMachineDetection = answeringMachineDetection;
  }

  public CallRequest answeringMachineDetectionConfig(CallRequestAnsweringMachineDetectionConfig answeringMachineDetectionConfig) {
    this.answeringMachineDetectionConfig = answeringMachineDetectionConfig;
    return this;
  }

   /**
   * Get answeringMachineDetectionConfig
   * @return answeringMachineDetectionConfig
  **/
  @Schema(description = "")
  public CallRequestAnsweringMachineDetectionConfig getAnsweringMachineDetectionConfig() {
    return answeringMachineDetectionConfig;
  }

  public void setAnsweringMachineDetectionConfig(CallRequestAnsweringMachineDetectionConfig answeringMachineDetectionConfig) {
    this.answeringMachineDetectionConfig = answeringMachineDetectionConfig;
  }

  public CallRequest customHeaders(List<CustomSipHeader> customHeaders) {
    this.customHeaders = customHeaders;
    return this;
  }

  public CallRequest addCustomHeadersItem(CustomSipHeader customHeadersItem) {
    if (this.customHeaders == null) {
      this.customHeaders = new ArrayList<>();
    }
    this.customHeaders.add(customHeadersItem);
    return this;
  }

   /**
   * Custom headers to be added to the SIP INVITE.
   * @return customHeaders
  **/
  @Schema(example = "[{\"name\":\"head_1\",\"value\":\"val_1\"},{\"name\":\"head_2\",\"value\":\"val_2\"}]", description = "Custom headers to be added to the SIP INVITE.")
  public List<CustomSipHeader> getCustomHeaders() {
    return customHeaders;
  }

  public void setCustomHeaders(List<CustomSipHeader> customHeaders) {
    this.customHeaders = customHeaders;
  }

  public CallRequest clientState(String clientState) {
    this.clientState = clientState;
    return this;
  }

   /**
   * Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
   * @return clientState
  **/
  @Schema(example = "aGF2ZSBhIG5pY2UgZGF5ID1d", description = "Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.")
  public String getClientState() {
    return clientState;
  }

  public void setClientState(String clientState) {
    this.clientState = clientState;
  }

  public CallRequest commandId(String commandId) {
    this.commandId = commandId;
    return this;
  }

   /**
   * Use this field to avoid duplicate commands. Telnyx will ignore commands with the same &#x60;command_id&#x60;.
   * @return commandId
  **/
  @Schema(example = "891510ac-f3e4-11e8-af5b-de00688a4901", description = "Use this field to avoid duplicate commands. Telnyx will ignore commands with the same `command_id`.")
  public String getCommandId() {
    return commandId;
  }

  public void setCommandId(String commandId) {
    this.commandId = commandId;
  }

  public CallRequest linkTo(String linkTo) {
    this.linkTo = linkTo;
    return this;
  }

   /**
   * Use another call&#x27;s control id for sharing the same call session id
   * @return linkTo
  **/
  @Schema(example = "ilditnZK_eVysupV21KzmzN_sM29ygfauQojpm4BgFtfX5hXAcjotg==", description = "Use another call's control id for sharing the same call session id")
  public String getLinkTo() {
    return linkTo;
  }

  public void setLinkTo(String linkTo) {
    this.linkTo = linkTo;
  }

  public CallRequest sipAuthUsername(String sipAuthUsername) {
    this.sipAuthUsername = sipAuthUsername;
    return this;
  }

   /**
   * SIP Authentication username used for SIP challenges.
   * @return sipAuthUsername
  **/
  @Schema(description = "SIP Authentication username used for SIP challenges.")
  public String getSipAuthUsername() {
    return sipAuthUsername;
  }

  public void setSipAuthUsername(String sipAuthUsername) {
    this.sipAuthUsername = sipAuthUsername;
  }

  public CallRequest sipAuthPassword(String sipAuthPassword) {
    this.sipAuthPassword = sipAuthPassword;
    return this;
  }

   /**
   * SIP Authentication password used for SIP challenges.
   * @return sipAuthPassword
  **/
  @Schema(description = "SIP Authentication password used for SIP challenges.")
  public String getSipAuthPassword() {
    return sipAuthPassword;
  }

  public void setSipAuthPassword(String sipAuthPassword) {
    this.sipAuthPassword = sipAuthPassword;
  }

  public CallRequest webhookUrl(String webhookUrl) {
    this.webhookUrl = webhookUrl;
    return this;
  }

   /**
   * Use this field to override the URL for which Telnyx will send subsuqeunt webhooks to for this call.
   * @return webhookUrl
  **/
  @Schema(example = "https://www.example.com/server-b/", description = "Use this field to override the URL for which Telnyx will send subsuqeunt webhooks to for this call.")
  public String getWebhookUrl() {
    return webhookUrl;
  }

  public void setWebhookUrl(String webhookUrl) {
    this.webhookUrl = webhookUrl;
  }

  public CallRequest webhookUrlMethod(WebhookUrlMethodEnum webhookUrlMethod) {
    this.webhookUrlMethod = webhookUrlMethod;
    return this;
  }

   /**
   * HTTP request type used for &#x60;webhook_url&#x60;.
   * @return webhookUrlMethod
  **/
  @Schema(example = "GET", description = "HTTP request type used for `webhook_url`.")
  public WebhookUrlMethodEnum getWebhookUrlMethod() {
    return webhookUrlMethod;
  }

  public void setWebhookUrlMethod(WebhookUrlMethodEnum webhookUrlMethod) {
    this.webhookUrlMethod = webhookUrlMethod;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CallRequest callRequest = (CallRequest) o;
    return Objects.equals(this.to, callRequest.to) &&
        Objects.equals(this.from, callRequest.from) &&
        Objects.equals(this.connectionId, callRequest.connectionId) &&
        Objects.equals(this.audioUrl, callRequest.audioUrl) &&
        Objects.equals(this.timeoutSecs, callRequest.timeoutSecs) &&
        Objects.equals(this.timeLimitSecs, callRequest.timeLimitSecs) &&
        Objects.equals(this.answeringMachineDetection, callRequest.answeringMachineDetection) &&
        Objects.equals(this.answeringMachineDetectionConfig, callRequest.answeringMachineDetectionConfig) &&
        Objects.equals(this.customHeaders, callRequest.customHeaders) &&
        Objects.equals(this.clientState, callRequest.clientState) &&
        Objects.equals(this.commandId, callRequest.commandId) &&
        Objects.equals(this.linkTo, callRequest.linkTo) &&
        Objects.equals(this.sipAuthUsername, callRequest.sipAuthUsername) &&
        Objects.equals(this.sipAuthPassword, callRequest.sipAuthPassword) &&
        Objects.equals(this.webhookUrl, callRequest.webhookUrl) &&
        Objects.equals(this.webhookUrlMethod, callRequest.webhookUrlMethod);
  }

  @Override
  public int hashCode() {
    return Objects.hash(to, from, connectionId, audioUrl, timeoutSecs, timeLimitSecs, answeringMachineDetection, answeringMachineDetectionConfig, customHeaders, clientState, commandId, linkTo, sipAuthUsername, sipAuthPassword, webhookUrl, webhookUrlMethod);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CallRequest {\n");
    
    sb.append("    to: ").append(toIndentedString(to)).append("\n");
    sb.append("    from: ").append(toIndentedString(from)).append("\n");
    sb.append("    connectionId: ").append(toIndentedString(connectionId)).append("\n");
    sb.append("    audioUrl: ").append(toIndentedString(audioUrl)).append("\n");
    sb.append("    timeoutSecs: ").append(toIndentedString(timeoutSecs)).append("\n");
    sb.append("    timeLimitSecs: ").append(toIndentedString(timeLimitSecs)).append("\n");
    sb.append("    answeringMachineDetection: ").append(toIndentedString(answeringMachineDetection)).append("\n");
    sb.append("    answeringMachineDetectionConfig: ").append(toIndentedString(answeringMachineDetectionConfig)).append("\n");
    sb.append("    customHeaders: ").append(toIndentedString(customHeaders)).append("\n");
    sb.append("    clientState: ").append(toIndentedString(clientState)).append("\n");
    sb.append("    commandId: ").append(toIndentedString(commandId)).append("\n");
    sb.append("    linkTo: ").append(toIndentedString(linkTo)).append("\n");
    sb.append("    sipAuthUsername: ").append(toIndentedString(sipAuthUsername)).append("\n");
    sb.append("    sipAuthPassword: ").append(toIndentedString(sipAuthPassword)).append("\n");
    sb.append("    webhookUrl: ").append(toIndentedString(webhookUrl)).append("\n");
    sb.append("    webhookUrlMethod: ").append(toIndentedString(webhookUrlMethod)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
